<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Stephan's blog</title><link>http://blog.sp.or.at</link><description>Stephan's notes on technology</description><lastBuildDate>Wed, 22 May 2013 18:25:16 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>git smart protocol via WebSockets - proof of concept</title><link>http://blog.sp.or.at/posts/201206git-smart-protocol-via-websockets-proof.html</link><description>&lt;p&gt;Yesterday an idea came to my mind: let's try running git's smart transport protocol via a WebSocket. In a few hours of work I came up with a solution which works.&lt;br&gt;&lt;br&gt;But why would one want to do that? Basically the only options for running git's smart protocol you have right now is either using git's own protocol or tunneling it via ssh. The first option leaves you without any ways of authentication - so it's only usable for read-only access to public repositories. The second option involves using an ssh server, which then allows read-write access and authentication, but is quite some work to set up.&lt;br&gt;As I am working on a university assignment which involves using WebSockets right now it occurred to me that there is no reason for not using WebSockets for this.&lt;br&gt;&lt;br&gt;The main idea is providing a tunnel, just like the ssh transport does, but this time via a WebSocket. The logic is the same and there is no modification to git itself required.&lt;br&gt;For now I have only implemented a proof of concept which allows you to update your repository from a remote system, but the approach should work perfectly well for pushing your changes to a remote repository too.&lt;br&gt;&lt;br&gt;Let's have a look at how this works.&lt;br&gt;On the local system &lt;i&gt;git-fetch-pack&lt;/i&gt; is invoked, which talks to a &lt;i&gt;git-upload-pack&lt;/i&gt; process on the remote end. The code I wrote provides a script which acts like an ssh client, but creates a WebSocket connection to the remote end, using Python and the &lt;a href="http://pypi.python.org/pypi/websocket-client/0.7.0"&gt;websocket-client&lt;/a&gt; Python package. On the other side of the tunnel a simple Python WSGI application, which uses &lt;a href="http://pypi.python.org/pypi/gevent-websocket/0.3.6"&gt;gevent-websocket&lt;/a&gt;, provides the server-side implementation.&lt;br&gt;Now when a WebSocket connection is established the server spawns a &lt;i&gt;git-upload-pack&lt;/i&gt; process and redirects its stdout to the WebSocket. Data which is received over the WebSocket is sent to the &lt;i&gt;git-upload-pack's &lt;/i&gt;stdin file descriptor.&lt;br&gt;On the client this logic is reversed, redirecting its stdout to the WebSocket and sending data received over the WebSocket to its stdin file descriptor.&lt;br&gt;&lt;br&gt;That's about it. Keep in mind this is a proof-of-concept, so there may be rough edges here and there and both stability and performance may be "sub-optimal".&lt;br&gt;I'd also like to point out that using WebSockets and HTTP as the underlying transport protocol gives one the opportunity to use standard HTTP(s) authentication mechanisms. This means that the WebSocket approach could be useful to git hosting sites, basically removing the need for running an ssh server.&lt;br&gt;&lt;br&gt;You can find the Python code over at &lt;a href="https://github.com/speijnik/gitws"&gt;https://github.com/speijnik/gitws&lt;/a&gt;. Have fun giving it a try.&lt;br&gt;&lt;br&gt;&lt;/p&gt;</description><category>http</category><category>gitws</category><category>websocket</category><category>git</category><category>proof of concept</category><category>python</category><guid>http://blog.sp.or.at/posts/201206git-smart-protocol-via-websockets-proof.html</guid><pubDate>Tue, 05 Jun 2012 05:08:00 GMT</pubDate></item><item><title>ptrace-based security just does not work</title><link>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</link><description>&lt;p&gt;In 2009 I &lt;a href="http://techandsp.blogspot.com/2009/12/introducing-ujail-proof-of-concept.html"&gt;wrote&lt;/a&gt; &lt;a href="http://techandsp.blogspot.com/2009/12/ujail-use-cases-faqs-part-1-proof-of.html"&gt;about&lt;/a&gt; building a ptrace-based sandboxing system named "ujail", including some basic proof of concepts.&lt;br&gt;&lt;br&gt;I have been thinking about this idea for a long time now, but sadly did not have the time to implement it - until now.&lt;br&gt;Right now I am working on this idea again and whilst doing some research I came across a &lt;a href="http://groups.google.com/group/linux.kernel/browse_thread/thread/4ef67613306dc260/b6fe32ed0fe7317a"&gt;thread&lt;/a&gt; on the linux-kernel mailing list.&lt;br&gt;At first a problem with 64-bit binaries trapping into 32-bit syscall handling code via int 80 got me there. While this is awkward and keeps one from implementing a sandbox in userspace (due to not being able to access &lt;i&gt;TS_COMPAT&lt;/i&gt;, as described in the thread) it led me to something else - a more severe problem.&lt;br&gt;Unfortunately I cannot remember who wrote this and am unable to recover the actual mail (if someone finds it I would be happy if you notified me), but someone mentioned race conditions when using &lt;i&gt;ptrace&lt;/i&gt; as a security measure.&lt;br&gt;&lt;br&gt;In short I came up with a proof of concept which works around possible limitations imposed by a ptrace-based security mechanism. For those in a hurry: you can find the code of the proof of concept at &lt;a href="https://github.com/speijnik/ptrace_security_flaws"&gt;github&lt;/a&gt;.&lt;br&gt;In the following parts of this article I would like to elaborate on the problem and how the proof of concept code exploits it.&lt;br&gt;&lt;a name="more"&gt;&lt;/a&gt;&lt;br&gt;The problem here is the fact that &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; traps &lt;b&gt;before&lt;/b&gt; the kernel actually fetches information from userspace.&lt;br&gt;Let me illustrate that with &lt;i&gt;sys_open&lt;/i&gt;. Assume we are running a tracer which makes use of ptrace to get a &lt;i&gt;SIGTRAP&lt;/i&gt; each time a tracee invokes a syscall and we want to impose limits on &lt;i&gt;sys_open&lt;/i&gt; calls.&lt;br&gt;&lt;br&gt;After a syscall has been invoked it would roughly work like this:&lt;br&gt;&lt;br&gt;The tracer is notified, evaluates the registers as read using &lt;i&gt;PTRACE_GETREGS&lt;/i&gt; and reads the first syscall argument's value (namely the path value) from the tracee. It then evaluates the value and decides whether to allow the syscall or not.&lt;br&gt;Now this is exactly the way ujail would have worked in its initial design. However, using this method there is a not-so-small attack vector which involves &lt;b&gt;all&lt;/b&gt; values read from the tracee's memory.&lt;br&gt;&lt;br&gt;You may now ask yourself what I am writing about, but it will make sense in a few moments, I promise.&lt;br&gt;&lt;br&gt;There is a timespan between the tracer reading the &lt;i&gt;path&lt;/i&gt; value from tracee's memory and the tracer actually resuming the tracee using &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; which allows a potentially malicious thread inside the tracee to change the value of the memory &lt;i&gt;path&lt;/i&gt; points to and thus circumvent any restriction imposed by the tracer. Changing the value is as simple as writing to the process memory, which is shared between threads, at just the right moment and to just the right position.&lt;br&gt;As writing to memory will not generate a trap the tracer could act upon the tracer would be unaware of the modification and it is just about to resume the tracee's execution - &lt;i&gt;jail broken&lt;/i&gt;.&lt;br&gt;&lt;br&gt;What is important here is just the right timing. The write has to happen after the tracer has read from the tracee's memory and before it resumes execution of the tracee. However, the tracer is most likely to employ some kind of decision-finding process here. This process will take time. It may actually involve some syscalls (think mutexes, semaphores and condition variables here). All in all enough time to swap values.&lt;br&gt;&lt;br&gt;You may now think to yourself that it might be really hard to actually pull this one off and it probably is in normal circumstances. However, the possibility to do this alone should rule-out ptrace as a security measure completely.&lt;br&gt;&lt;br&gt;The only way I believe this could be handled is triggering a hook inside the system call handlers themselves, just after all information has been pulled from userspace. These values are guaranteed not to be modifiable from within userspace and thus only these should be considered for making decisions. As a consequence ujail (and every other similar security measure out there) will have to be realized at least partly in kernel-space.&lt;br&gt;&lt;br&gt;Feel free to leave comments, send me an email and/or point out any issues with the proof of concept code or my idea.&lt;/p&gt;</description><category>ujail</category><category>sandbox</category><category>ptrace</category><category>security</category><category>GNU/Linux</category><guid>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</guid><pubDate>Fri, 24 Feb 2012 14:48:00 GMT</pubDate></item><item><title>How to force a local DNS resolver to be used using resolvconf</title><link>http://blog.sp.or.at/posts/201106how-to-force-local-dns-resolver-to-be.html</link><description>&lt;p&gt;I know it has been a while, but after reading a &lt;a href="http://www.progsoc.org/~wildfire/aum/2011/06/01#bind2"&gt;blog post&lt;/a&gt; by Anand Kumria over at &lt;a href="http://planet.debian.org/"&gt;planet.debian.org&lt;/a&gt; I decided to have a quick look at one of the problems he described.&lt;br&gt;&lt;br&gt;Basically, Anand wants to force the local resolver to be used for each and every network connection, may that connection be established manually or via NetworkManager. He wrote that fixing this configuration for every new connection manually is tedious, and I fully agree on that. So here is a solution to do this all automatically, using &lt;i&gt;resolvconf&lt;/i&gt;:&lt;br&gt;&lt;br&gt;After installing the &lt;i&gt;resolvconf&lt;/i&gt; package every time &lt;i&gt;/etc/resolv.conf&lt;/i&gt; is to be updated &lt;i&gt;resolvconf&lt;/i&gt; takes care of that. Using the files in &lt;i&gt;/etc/resolvconf&lt;/i&gt; this process can be controlled and the resulting file modified to fit one own's needs.&lt;br&gt;&lt;br&gt;So at first we would like the local resolver to be used for every connection. This works by simply adding the "nameserver 127.0.0.1" directive to the &lt;i&gt;/etc/resolvconf/resolv.conf.d/head&lt;/i&gt; file. Simple as that. Every time &lt;i&gt;/etc/resolv.conf&lt;/i&gt; gets generated the contents of the head file are actually used as &lt;i&gt;/etc/resolv.conf&lt;/i&gt;'s header.&lt;br&gt;&lt;br&gt;Using this method the local resolver is used for every connection. But Anand wanted to use &lt;b&gt;only&lt;/b&gt; the local resolver and discard any resolvers possibly obtained via DHCP for example. Guess what, this is also possible using resolvconf.&lt;br&gt;&lt;br&gt;Adding &lt;i&gt;TRUNCATE_NAMESERVER_LIST_AFTER_127="yes"&lt;/i&gt; to &lt;i&gt;/etc/default/resolvconf&lt;/i&gt; does exactly that. Now every &lt;i&gt;nameserver&lt;/i&gt; directive after the 127.0.0.1 one is ignored and will not make it into /&lt;i&gt;etc/resolv.conf&lt;/i&gt;. You can of course add more nameservers to the &lt;i&gt;head&lt;/i&gt; file above the 127.0.0.1 directive.&lt;br&gt;&lt;br&gt;Problem fixed I guess.&lt;br&gt;Don't forget to re-connect to the network or manually force re-creation of &lt;i&gt;/etc/resolv.conf&lt;/i&gt; so the changes you made get populated. I really hope this is of use to some of you facing similar problems.&lt;/p&gt;</description><category>DNS</category><category>Debian</category><category>NetworkManager</category><category>GNU/Linux</category><category>Networking</category><guid>http://blog.sp.or.at/posts/201106how-to-force-local-dns-resolver-to-be.html</guid><pubDate>Wed, 01 Jun 2011 18:53:00 GMT</pubDate></item><item><title>ISC dhcpd and IP assignments from a pool to specific hosts only</title><link>http://blog.sp.or.at/posts/201101isc-dhcpd-and-ip-assignments-from-pool.html</link><description>&lt;p&gt;Assigning an IP address statically to a host with a given MAC address using ISC dhcpd is quite trivial, one host entry, a hardware ethernet entry and a fixed-address entry and you are up and running.&lt;br&gt;But what if you want to assign IP addresses from a pool to only a few hosts with specific MAC addresses?&lt;br&gt;&lt;br&gt;Before you ask yourself why someone might want to do that, have a look at my (very real) use-case.&lt;br&gt;I am currently working on setting up an installation server for my employer, &lt;a href="http://www.anexia.at/"&gt;ANEXIA Internetdienstleistungs GmbH&lt;/a&gt;. The server itself uses PXE, TFTP and FAI for installing systems. To be able to do PXE booting one has to set up an DHCP server to provide configuration details, like the TFTP Server Address and the boot filename.&lt;br&gt;&lt;br&gt;Now what one should consider is that this system is designed to provide automatic installations for internet-facing hosts, namely ones in public IP networks. Running a DHCP server in such a network is not a good idea. We neither want to dish out configurations to each and every hosts that asks for them, neither do not want to do a PXE boot each and every time one of our systems is restarted. Now the combination of FAI and pxelinux allows for default configurations which force local booting, but this still causes the (re-)boot time for those systems to increase and potentially also increases the load on the TFTP server. Also, let's not even consider thinking about whether this setup is "clean" or not. I personally believe that dishing out IP addresses in a public IP network is a bad thing(tm) and I guess a lot of people will be nodding when reading these lines.&lt;br&gt;&lt;br&gt;What I was asking myself is how to get something like that set up in a cleaner way, and guess what, I found a solution.&lt;br&gt;The basic idea behind this is only providing IP configuration via DHCP to a specific set of hosts (with a specific set of MAC addresses) and not providing any information to all other hosts. The specific set of hosts are those that we want to do an install run on. This is a no-brainer and I guess the right way to do that, but implementing this approach is not as straight-forward as I initially thought.&lt;br&gt;&lt;br&gt;Actually the implementation of that idea caused me a bit of a headache and cost me a few work-hours to get right, that's why I'd like to share the configuration details with you.&lt;br&gt;&lt;br&gt;&lt;a name="more"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;Let's have a look at how to get such a setup using ISC dhcpd. We are using the fact that ISC dhcpd allows you to not only configure a subnet, but rather also pools inside subnets, which can have allow and deny rules. Such rules can be in the form of "allow/deny member of ", where classes (and subclasses, keep on reading for details) can be defined inside the configuration file as well.&lt;br&gt;&lt;br&gt;What we first did was creating a subnet with a pool declaration, as follows:&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;i&gt;subnet 10.0.0.0 netmask 255.255.255.0 {  &lt;/i&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    option routers &lt;span class="Apple-style-span" style="font-style: normal;"&gt;&lt;i&gt;10.0.0.254&lt;/i&gt;&lt;/span&gt;;&lt;/i&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    option broadcast-address &lt;span class="Apple-style-span" style="font-style: normal;"&gt;&lt;i&gt;10.0.0.&lt;/i&gt;&lt;/span&gt;255;&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    filename "fai/pxelinux.0";&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    next-server &lt;span class="Apple-style-span" style="font-style: normal;"&gt;&lt;i&gt;10.0.0.254&lt;/i&gt;&lt;/span&gt;;&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    server-name "10.0.0.254";&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;    pool { &lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;      allow members of "install"; &lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;      range 10.0.0.10 10.0.0.230; &lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;   }&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;}&lt;/i&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;This one configures the subnet 10.0.0.0/24, with 10.0.0.254 being the network gateway, 10.0.0.254 being the TFTP server and "fai/pxelinux.0" being the TFTP filename. Additionally pool allows us to define a range of IP addresses we want to use, along with a line stating that only members of the "install" class should get a network configuration. If you do not have any other subnet defined in your config and a client that is not in this "install" class asks for an IP address you will see something like this in your syslog:  "&lt;i&gt;dhcpd: DHCPDISCOVER from 11:22:33:44:55:66 via eth1: network 10.0.0/24: no free leases&lt;/i&gt;". dhcpd will not even answer these requests and thus the client will not even know that there is a DHCP server running here. Exactly what we wanted.&lt;br&gt;&lt;br&gt;I wrote about this giving me a headache, but so far things have been pretty straight-forward. Getting this far did not take very long, believe me.&lt;br&gt;&lt;br&gt;Next thing we did was defining that "install" class as follows:&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;&lt;i&gt;class "install" { match hardware; }&lt;/i&gt;&lt;/blockquote&gt;Again, not very hard to do. This tells dhcpd to look for subclasses of "install" with a matching hardware-address. So let's have a look at the subclass for, let's say the host with MAC address "11:22:33:44:55:66":&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;&lt;i&gt;subclass "install" &lt;b&gt;1:&lt;/b&gt;11:22:33:44:55:66;&lt;/i&gt;&lt;/blockquote&gt;I intentionally highlighted the leading "1:" there. This means nothing more or less than "ethernet". Without that leading "1:" you won't get anywhere. Matching will fail, simple as that. It took me a while to find  information about this in "&lt;i&gt;man 5 dhcp-eval&lt;/i&gt;". Quoting parts of the interesting section:&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;i&gt;The hardware operator returns a data string whose first  element  is&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;the  type of network interface indicated in packet being considered,&lt;/i&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;i&gt;and whose subsequent elements are client’s link-layer address. [...] Hardware types include  ethernet  (1),  token-ring  (6), and fddi (8).&lt;/i&gt;&lt;/blockquote&gt;&lt;/blockquote&gt; Now, with the combination of the subnet, pool, class and subclass directives we could get the setup we wanted: a DHCP server only providing IP configuration to a specific set of hosts and ignoring all other DHCP requests.&lt;br&gt;&lt;br&gt;If you have any comments about this setup or ideas on how to get something similar set-up using another approach feel free to leave a comment.&lt;br&gt;&lt;br&gt;Personal final note: accidentally typing 80 instead of 08 in a MAC address will cost you an additional two hours and will even have you re-compile ISC dhcpd with eval debugging turned on, believe me. :-)</description><category>Technology</category><category>dhcpd</category><category>sysadmin</category><category>Networking</category><category>isc dhcpd</category><guid>http://blog.sp.or.at/posts/201101isc-dhcpd-and-ip-assignments-from-pool.html</guid><pubDate>Sat, 01 Jan 2011 21:01:00 GMT</pubDate></item><item><title>What's all the fuzz about canonical-census?</title><link>http://blog.sp.or.at/posts/201008whats-all-fuzz-about-canonical-census.html</link><description>&lt;p&gt;I know I have not updated this blog in quite a long time now, but something caught my attention today: canonical-census.&lt;br&gt;&lt;br&gt;As slashdot.org &lt;a href="http://linux.slashdot.org/story/10/08/10/0319243/Canonical-Begins-Tracking-Ubuntu-Installations"&gt;reports&lt;/a&gt; Canonical begins with tracking their (OEM) installations. Now it's obvious that people are uncomfortable with a program running on their system which phones back to their OS vendor, that's why I have had a quick look at what exactly canonical-census does.&lt;br&gt;&lt;br&gt;Firstly however, I would like to point out that the report on slashdot.org is very clear about which information is being gathered, being "&lt;i&gt;the number of times this system previously sent to Canonical [...], the Ubuntu distributor channel, the product name as acquired by the system's DMI information, and which Ubuntu release is being used&lt;/i&gt;". And it's perfectly correct. After getting the canonical-census Debian source package (using dget -u https://launchpad.net/ubuntu/+archive/partner/+files/canonical-census_0.1.dsc) the source package shows, besides the Debian packaging information, two scripts:&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;census (written in Python) and&lt;/li&gt;&lt;li&gt;send-census (a GNU bash script).&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Now what do those scripts actually do?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;send-census&lt;/b&gt; is installed in /etc/cron.daily, which means it will be executed once a day by the system's cron daemon. It's a mere 48 lines long, and its code is quite simple. So everyone with at least some shell scripting experience can easily check what it's doing. Now guess what, it sends exactly the information as reported on slashdot to Canonical. Nothing more and nothing less.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Technically it keeps a plain text file containing a single number as its call-counter, residing in &lt;i&gt;/var/lib/send-install-count/counter&lt;/i&gt; and uses an on my Ubuntu Lucid system nonexistent &lt;i&gt;/var/lib/ubuntu_dist_channel&lt;/i&gt; file for getting information about the distribution channel.&lt;/div&gt;&lt;div&gt;The above mentioned "system's DMI information" is not the whole bunch of DMI information available, but only the contents of &lt;i&gt;/sys/class/dmi/id/product_name&lt;/i&gt;, which strangely enough returns "System Product Name" on my machine. Last but not least it uses lsb-release to get the distribution release (ie. 10.04 for my system).&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Now those four pieces of information are sent to &lt;i&gt;http://census.canonical.com/submit&lt;/i&gt; via a simple HTTP GET query, using wget. The full URL with all the parameters added is:&lt;br&gt;&lt;i&gt;http://census.canonical.com/submit?count=&lt;b&gt;count&lt;/b&gt;&amp;amp;dcd=&lt;b&gt;dist_channel&lt;/b&gt;&amp;amp;product=&lt;b&gt;dmi_product_name&lt;/b&gt;&amp;amp;release=&lt;b&gt;ubuntu_release_version&lt;/b&gt;&lt;/i&gt;&lt;/div&gt;&lt;div&gt;&lt;i&gt;&lt;br&gt;&lt;/i&gt;&lt;/div&gt;&lt;div&gt;The second script, &lt;b&gt;census&lt;/b&gt;, is the part working on Canonical's script. Basically census reads in their Apache's access log file and creates an SQLite database from the contents of the log file. With 391 lines this script is a bit longer, but it does not end up in the Debian package at all.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Personally I do not see how Canonical or one of their partners could possibly do anything harmful with that information. Comparing this to Debian's popcon reveals that Debian is gathering a lot more information.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Now there are two more things one should consider: census is targeted at OEMs, which means its unlikely that it will end up on each and every Ubuntu installation and can be uninstalled by removing the canonical-census package with your favorite package manager.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Finally, think about this for a second: It's a shell script you can always examine. There is no hidden magic and it's a plain HTTP request the script is sending. No evil things happening there.&lt;br&gt;And now compare that to what other (often proprietary) software vendors do and how much data they submit, possibly even in encrypted form so you do not know for sure what is being sent to them.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Personally I welcome the openness of Canonical with providing their users with the package's code this early and being straight about what information it submits. They could have silently added it to those installations after all...&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Happy hacking!&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;</description><category>Canonical</category><category>Ubuntu</category><guid>http://blog.sp.or.at/posts/201008whats-all-fuzz-about-canonical-census.html</guid><pubDate>Tue, 10 Aug 2010 11:07:00 GMT</pubDate></item><item><title>Rest in peace Flo: 13.11.1986–16.12.2009</title><link>http://blog.sp.or.at/posts/200912rest-in-peace-flo-1311198616122009.html</link><description>&lt;p&gt;Today is a sad day. Everything feels like I am having a bad nightmare. That's because today I learnt from the too early death of my friend &lt;a href="http://florianhufsky.soup.io/"&gt;Florian Hufksy&lt;/a&gt;.&lt;br&gt;&lt;br&gt;I am sitting here and do not really know what to write. I keep on thinking about the great times we spent together. The time we started programming when we were twelve. The time we spent learning BASIC. All the times you knew more than me and could teach me a thing or two. I remember our geek talks. How we would discuss latest games. How we lost contact and how we met again. I am thinking about how sorry I am for not having met you often enough. I keep on trying to understand what drove you that far. How you could just end it all. More and more memories come to my mind, like the moment when you showed me one of your projects, Super Mario War. The moments we had playing video games together. All those moments, all that time, I miss you my friend. You were a genius, always a step ahead, not only of me, but seemingly the whole world. I can't stop thinking about your brilliant ideas and how you always finished your projects. You were a real hacker, a real genius, a person trying to make the world a better place, a person who will be missed, not only by me.&lt;br&gt;&lt;br&gt;You were a genius and I always respected you, not only as a hacker, but as a beloved friend. Why did we not spend more time together? Why did you have to go? Why do I have to write this now, sitting here in my chair with tears in my eyes? And all those memories come up again and again.  There is so much more that comes to my mind, but I can't keep on writing, it just hurts too much.&lt;br&gt;&lt;br&gt;The world is a sad place today. I am sad. I am mourning the too early death of my beloved friend, Florian. You will always have a special place in my heart.&lt;/p&gt;</description><guid>http://blog.sp.or.at/posts/200912rest-in-peace-flo-1311198616122009.html</guid><pubDate>Sat, 19 Dec 2009 22:15:00 GMT</pubDate></item><item><title>ujail: use cases, FAQs, part 1 &amp; proof of concept, part 2</title><link>http://blog.sp.or.at/posts/200912ujail-use-cases-faqs-part-1-proof-of.html</link><description>&lt;p&gt;As I ran out of time whilst writing the "&lt;a href="http://techandsp.blogspot.com/2009/12/introducing-ujail-proof-of-concept.html"&gt;introducing ujail&lt;/a&gt;" post on monday I would like to further elaborate on the idea, giving you some examples of possible use cases and then having a look at FAQs regarding ujail. Additionally I have created a second proof of concept that should be a lot faster, see below for more details.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use cases of ujail&lt;/b&gt; &lt;br&gt;&lt;br&gt;Monday's post was rather technical, so let's have a look at possible use cases today.&lt;br&gt;&lt;br&gt;The main reason for both having the idea of ujail and starting working on it is my web server. I am running quite a few (S)CGI scripts there and, even though running them as different users, on a per-vhost basis, I have the impression of the whole thing being a bit insecure.&lt;br&gt;&lt;br&gt;Okay, PHP does provide its famous &lt;i&gt;open_basedir&lt;/i&gt; feature, but I am also running some Python applications which I simply cannot restrict easily. My first ideas involved adding something similar to open_basedir to Python, followed by the idea of replacing some C library functions, like fopen and friends on startup time.&lt;br&gt;&lt;br&gt;Whilst the adding open_basedir to Python would have involved changing a lot of Python's internals I soon discarded the library patching idea as those could be worked around by injected code directly invoking syscalls. It didn't take long for me to notice that I have to dig deeper. The idea of ujail was born and after coming up with the proof of concept this seems to be a viable solution.&lt;br&gt;&lt;br&gt;Now ujail is not only about protecting a web server from its web applications, but could do a lot more, for example:&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Creating a sandbox for untrusted code (socket&amp;amp;file i/o emulation)&lt;br&gt;&lt;/li&gt;&lt;li&gt;Implementing some sort of personal firewall (socket-call only emulation)&lt;/li&gt;&lt;li&gt;Testing applications that perform low-level system operations (read: package managers and friends, filesystem emulation)&lt;/li&gt;&lt;/ul&gt; I am sure you can come up with even more use-cases. What should be noted is that emulating a system call does not mean that one necessarily needs to emulate the whole filesystem. What can be done, for example, is patching through access to common files (libraries, executables, etc.) whilst maintaining a virtual filesystem for data that will eventually be modified. A copy-on-write approach is possible too, for example. There are multiple methods with which the multiple filesystem could be implemented, the most common would probably be using a state directory.&lt;br&gt;&lt;br&gt;&lt;b&gt;FAQs&lt;/b&gt;&lt;br&gt;&lt;br&gt;There have been some questions about ujail in comments to my first post which I would like to answer. Also, I have been thinking about things that are different about ujail compared to other virtualization techniques. Feel free to add additional questions either in a comment or drop me an email: debian at sp dot or dot at.&lt;br&gt;&lt;br&gt;&lt;ol&gt;&lt;li&gt;Could you change the license of ujail to ... ?&lt;br&gt;&lt;br&gt;Not likely to happen. The proof of concept's license is GPLv3 and the actual code's license will be too. However, ujail is a userspace application that does not need any modifications to the kernel so there should be no problems with porting ujail from GNU/Linux to any other system.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Does ujail work on operating systems other than GNU/Linux?&lt;br&gt;&lt;br&gt;Not yet. If it's technically possible to implement the technique on other operating systems I would be happy to accept patches.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Do I need to patch my kernel for ujail to work?&lt;br&gt;&lt;br&gt;No, ujail is running in userspace. The only thing it needs is Linux with support for PTRACE_SYSEMU.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from using LD_PRELOAD?&lt;br&gt;&lt;br&gt;With LD_PRELOAD one can replace library functions, but malicious code could still directly invoke syscalls, working around this protection completely. Also, statically linked binaries cannot be restricted with LD_PRELOAD.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from user-mode-linux?&lt;br&gt;&lt;br&gt;User-mode-linux (UML) works by emulating a full kernel in userspace and allows you to virtualize a whole Linux instance (including a new init process, etc). ujail is about providing a way of restricting a single process (and its childs) inside a running system in terms of access to syscalls and the partial emulation of those.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from linux-vserver?&lt;br&gt;&lt;br&gt;Linux-vserver is a kernel patch and runs in kernel space, as opposed to ujail, which works in userspace.&lt;br&gt;Also, linux-vserver works similarly to user-mode-linux, providing a fully virtualized Linux instance.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Does the account running ujail need any special privileges?&lt;br&gt;&lt;br&gt;No, the only restrictions that apply are those of ptrace.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Where is the code?&lt;br&gt;&lt;br&gt;Right now ujail is in a planning phase, and only the proof of concept code has been written and published. The actual ujail code is yet to be written and the code will be hosted on &lt;a href="http://launchpad.net/ujail"&gt;launchpad.net&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;b&gt;Proof of concept, part 2&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;An anonymous person (who were you stranger?) added a comment to my first post, suggesting "&lt;i&gt;Also, why patch the process rather than just modifying its state and trapping into the kernel?&lt;/i&gt;". I have had a look at this approach earlier, but it didn't work out. However, I decided to give it yet another try and created a &lt;a href="http://bazaar.launchpad.net/%7Espeijnik/ujail/proof-of-concept/revision/3"&gt;second proof of concept&lt;/a&gt;. That code does not require patching any code, but only modifies the instruction pointer (eip) and the first register (eax). This should be a lot faster than patching the code.&lt;br&gt;&lt;br&gt;Technically the new main loop works by calling PTRACE_SYSEMU and waiting for a notification. It then saves the instruction pointer and switches to PTRACE_SYSCALL. As before it waits for the emulated syscall to exit and at this point sets eax from orig_eax and decreases the value of the instruction pointer by the size of the "&lt;i&gt;int $0x80&lt;/i&gt;" instruction. Another call to PTRACE_SYSCALL resumes the process. The next event is the process actually entering the real syscall and yet another one leaving the syscall again. These are resumed by PTRACE_SYSCALL and PTRACE_SYSEMU respectively. So, comparing this with the first approach we are only modifying two registers now, instead of writing to the TEXT area of the running process.&lt;br&gt;&lt;br&gt;Thanks should go to the anonymous commenter for making me give this approach another try.&lt;br&gt;&lt;br&gt;&lt;b&gt;Questions? Criticism? More ideas? Want to contribute?&lt;/b&gt;&lt;br&gt;&lt;br&gt;Coming to an end I would yet again like to let you know that I am  open for questions, criticism, more ideas and contributions in general. So if you are interested in this topic come join the discussion by either dropping me an email, writing a comment to this post or replying to this post on your own blog.</description><category>Technology</category><category>ujail</category><category>GNU/Linux</category><category>free software</category><guid>http://blog.sp.or.at/posts/200912ujail-use-cases-faqs-part-1-proof-of.html</guid><pubDate>Wed, 09 Dec 2009 09:16:00 GMT</pubDate></item><item><title>Introducing ujail &amp; proof of concept</title><link>http://blog.sp.or.at/posts/200912introducing-ujail-proof-of-concept.html</link><description>&lt;p&gt;Lately I have been thinking about methods to provide a stripped down, secured environment for running untrusted code on GNU/Linux. With this post I would like to present you with the first results of my research.&lt;br&gt;&lt;br&gt;&lt;b&gt;ujail - brief introduction&lt;/b&gt;&lt;br&gt;&lt;br&gt;I have chosen &lt;a href="http://launchpad.net/ujail"&gt;ujail&lt;/a&gt; as the name for the technique I am proposing. ujail stands for micro jail in userspace and, in itself, describes the concept briefly. The main idea is to have a userspace process monitor system calls of one of its childs and emulate some calls, if needed. This is done using ptrace and namely both PTRACE_SYSEMU and PTRACE_SYSCALL.&lt;br&gt;The ujail process should not be able to monitor syscalls, like strace does, but also intercept and emulate them.&lt;br&gt;&lt;br&gt;This sounds a lot like user mode linux (uml), but the method is different. Whilst uml comes with a complete kernel, emulates all system calls and this way provides a virtualized system, ujail is intended to only emulate some systemcalls, without emulating the kernel.&lt;br&gt;&lt;br&gt;&lt;b&gt;Revisiting PTRACE_SYSCALL &amp;amp; PTRACE_SYSEMU&lt;/b&gt;&lt;br&gt;&lt;br&gt;To better explain how the ujail technique works I would like to have a quick look at PTRACE_SYSCALL and PTRACE_SYSEMU again.&lt;br&gt;&lt;br&gt;PTRACE_SYSCALL allows a userspace process to be notified whenever a traced process enters or leaves a system call. This means that two notifications are normally sent: one before system call entry and one afterwards. Even though one is able to change the parameters of system calls this method does not allow system calls to be fully emulated (think virtual filesystem here).&lt;br&gt;&lt;br&gt;PTRACE_SYSEMU on the other hand provides one notification on syscall entry and expects the receiver of the notification to emulate the syscall. This method alone sounds great, but this also means that memory allocation needs to be emulated too, which is quite complex in userspace.&lt;br&gt;&lt;br&gt;&lt;b&gt;A hybrid of PTRACE_SYSCALL &amp;amp; PTRACE_SYSEMU&lt;/b&gt;&lt;br&gt;&lt;br&gt;Now on to the concept behind ujail. The method I am describing works by calling PTRACE_SYSEMU for a specific process and this way taking over emulation of all system calls. However, some system calls are complex to emulate in userspace, and so a hybrid of both PTRACE_SYSEMU and PTRACE_SYSCALL is needed. In short this works by checking whether the syscall needs to be emulated when the PTRACE_SYSEMU event is received.&lt;br&gt;Now one way is emulating the syscall, filling the processes' registers and resuming execution of the process. This is simple and straight-forward.&lt;br&gt;&lt;br&gt;The second way is forwarding the system call to the kernel. The problem here is that calling the syscall in the monitoring process will make the new resources available to that very process, and not the process to be jailed. This is where the hybrid method kicks in.&lt;br&gt;&lt;br&gt;The proof of concept code creates a backup of the next instruction to be executed along with a copy of the instruction pointer at this point and patches it with the opcodes for "int $0x80", causing the syscall to be made again. After that it resumes execution with PTRACE_SYSCALL and waits again. The first event to be received now is the program leaving the emulated system call, which can be ignored. Resuming yet again will give use two PTRACE_SYSCALL events, one for syscall entry and one for syscall exit.&lt;br&gt;&lt;br&gt;The first event is not really interesting, but at the second event the opcode backup is restored and the eip set from the saved value. Now the kernel has handled the syscall and the result is ready for the child process. A final call of PTRACE_SYSEMU resumes execution of the child and waits for the next syscall.&lt;br&gt;&lt;br&gt;&lt;b&gt;Proof of concept&lt;/b&gt;&lt;br&gt;&lt;br&gt;The proof of concept code can be downloaded from its &lt;a href="https://code.launchpad.net/%7Espeijnik/ujail/proof-of-concept"&gt;bazaar branch&lt;/a&gt; at launchpad.net. It is intended to be used on i386 systems only and works with simple programs, but is known not to work with anything using fork, vfork and most likely will not work for binaries using threading.&lt;br&gt;&lt;br&gt;Finally, I would like to thank &lt;a href="http://www.linuxjournal.com/user/800841" title="View user profile."&gt;Pradeep Padala&lt;/a&gt; for his "Playing with ptrace" articles &lt;a href="http://www.linuxjournal.com/article/6100"&gt;[0]&lt;/a&gt;&lt;a href="http://www.linuxjournal.com/article/6210"&gt;[1]&lt;/a&gt;, which were fun to read and worked as a great introduction of ptrace for me. &lt;br&gt;&lt;br&gt;Now there is only one thing left to say: if you are interested in this method, see loopholes or problems or want to contribute, please go ahead and contact me:&lt;br&gt;&lt;br&gt;debian at sp dot or dot at&lt;/p&gt;</description><category>Technology</category><category>ujail</category><category>GNU/Linux</category><category>free software</category><guid>http://blog.sp.or.at/posts/200912introducing-ujail-proof-of-concept.html</guid><pubDate>Mon, 07 Dec 2009 15:49:00 GMT</pubDate></item><item><title>How to copy partitions under GNU/Linux the easy way</title><link>http://blog.sp.or.at/posts/200912how-to-copy-partitions-under-gnulinux.html</link><description>&lt;p&gt;After getting a new disk for my Popcorn Hour A-110 device I had to copy all partitions from the old disk onto the new one so I do not have to reinstall some applications and reconfigure everything.&lt;br&gt;&lt;br&gt;After searching the web and trying to find a free alternative to Norton Ghost and Acronis True Image, preferably not using a boot disk on its own (I did not want to backup my workstation after all, just a simple partition to partition copy between two SATA disks) I gave up and decided to do the copying manually.&lt;br&gt;&lt;br&gt;So I fired up gparted to do the partitioning, did a right click and... I noticed that gparted supports copy/paste. Being curious about what this could potentially do I gave it a try. I marked partition one on the old disk, did a copy, went to the new disk and clicked on paste - and guess what, gparted did what I was looking for.&lt;br&gt;&lt;br&gt;Putting a long story short: you can copy whole partitions using gparted's copy/paste mechanism and even resize them whilst doing so. I am somehow ashamed I did not notice this feature earlier, having been a gparted user for a few years now and I can imagine I am not the only one who missed that.&lt;/p&gt;</description><category>Technology</category><category>gparted</category><category>free software</category><guid>http://blog.sp.or.at/posts/200912how-to-copy-partitions-under-gnulinux.html</guid><pubDate>Tue, 01 Dec 2009 16:22:00 GMT</pubDate></item><item><title>kvm, qemu and the magic of ubuntu-vm-builder</title><link>http://blog.sp.or.at/posts/200911kvm-qemu-and-magic-of-ubuntu-vm-builder.html</link><description>&lt;p&gt;As I &lt;a href="http://techandsp.blogspot.com/2009/11/my-android-repositories.html"&gt;noted&lt;/a&gt; two days ago I was unable to build Android on Ubuntu 9.10 x86-64 and thus needed to set up a virtual machine.&lt;br&gt;&lt;br&gt;At first I went for my preferred virtualization solution, &lt;a href="http://www.virtualbox.org/"&gt;VirtualBox&lt;/a&gt; and had to notice that even though I assigned all 4 processor cores of my workstation (along with 2GiB of memory) to the virtual machine building was painfully slow. I immediately ditched the idea of using  VirtualBox again and decided to give something new to me a try: the combination of &lt;a href="http://www.linux-kvm.org/page/Main_Page"&gt;kvm&lt;/a&gt; and &lt;a href="http://www.qemu.org/"&gt;qemu&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Having Intel VT-x support built into my workstation's processor I thought that this combination should give better performance, and I wasn't disappointed. To be honest, I am astonished on how fast the beast is now. Disk speed still seems to be not as fast as running things natively, but there must be a downside somewhere. :-)&lt;br&gt;&lt;br&gt;After a bit of googling I also found that &lt;a href="https://launchpad.net/vmbuilder"&gt;ubuntu-vm-builder&lt;/a&gt; exists, which simplifies virtual system creation tremendously.&lt;br&gt;&lt;br&gt;My Android working tree is being synchronized right now, which means that I should be able to start building in a few minutes time. I hope the virtual machine stays as fast as it is right now during the build and I hope everything goes well.&lt;/p&gt;</description><category>Technology</category><category>Android</category><category>free software</category><category>Ubuntu</category><guid>http://blog.sp.or.at/posts/200911kvm-qemu-and-magic-of-ubuntu-vm-builder.html</guid><pubDate>Wed, 11 Nov 2009 07:25:00 GMT</pubDate></item></channel></rss>