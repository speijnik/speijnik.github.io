<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Stephan's blog (security)</title><link>http://blog.sp.or.at</link><description>Stephan's notes on technology</description><lastBuildDate>Wed, 22 May 2013 18:25:16 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>ptrace-based security just does not work</title><link>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</link><description>&lt;p&gt;In 2009 I &lt;a href="http://techandsp.blogspot.com/2009/12/introducing-ujail-proof-of-concept.html"&gt;wrote&lt;/a&gt; &lt;a href="http://techandsp.blogspot.com/2009/12/ujail-use-cases-faqs-part-1-proof-of.html"&gt;about&lt;/a&gt; building a ptrace-based sandboxing system named "ujail", including some basic proof of concepts.&lt;br&gt;&lt;br&gt;I have been thinking about this idea for a long time now, but sadly did not have the time to implement it - until now.&lt;br&gt;Right now I am working on this idea again and whilst doing some research I came across a &lt;a href="http://groups.google.com/group/linux.kernel/browse_thread/thread/4ef67613306dc260/b6fe32ed0fe7317a"&gt;thread&lt;/a&gt; on the linux-kernel mailing list.&lt;br&gt;At first a problem with 64-bit binaries trapping into 32-bit syscall handling code via int 80 got me there. While this is awkward and keeps one from implementing a sandbox in userspace (due to not being able to access &lt;i&gt;TS_COMPAT&lt;/i&gt;, as described in the thread) it led me to something else - a more severe problem.&lt;br&gt;Unfortunately I cannot remember who wrote this and am unable to recover the actual mail (if someone finds it I would be happy if you notified me), but someone mentioned race conditions when using &lt;i&gt;ptrace&lt;/i&gt; as a security measure.&lt;br&gt;&lt;br&gt;In short I came up with a proof of concept which works around possible limitations imposed by a ptrace-based security mechanism. For those in a hurry: you can find the code of the proof of concept at &lt;a href="https://github.com/speijnik/ptrace_security_flaws"&gt;github&lt;/a&gt;.&lt;br&gt;In the following parts of this article I would like to elaborate on the problem and how the proof of concept code exploits it.&lt;br&gt;&lt;a name="more"&gt;&lt;/a&gt;&lt;br&gt;The problem here is the fact that &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; traps &lt;b&gt;before&lt;/b&gt; the kernel actually fetches information from userspace.&lt;br&gt;Let me illustrate that with &lt;i&gt;sys_open&lt;/i&gt;. Assume we are running a tracer which makes use of ptrace to get a &lt;i&gt;SIGTRAP&lt;/i&gt; each time a tracee invokes a syscall and we want to impose limits on &lt;i&gt;sys_open&lt;/i&gt; calls.&lt;br&gt;&lt;br&gt;After a syscall has been invoked it would roughly work like this:&lt;br&gt;&lt;br&gt;The tracer is notified, evaluates the registers as read using &lt;i&gt;PTRACE_GETREGS&lt;/i&gt; and reads the first syscall argument's value (namely the path value) from the tracee. It then evaluates the value and decides whether to allow the syscall or not.&lt;br&gt;Now this is exactly the way ujail would have worked in its initial design. However, using this method there is a not-so-small attack vector which involves &lt;b&gt;all&lt;/b&gt; values read from the tracee's memory.&lt;br&gt;&lt;br&gt;You may now ask yourself what I am writing about, but it will make sense in a few moments, I promise.&lt;br&gt;&lt;br&gt;There is a timespan between the tracer reading the &lt;i&gt;path&lt;/i&gt; value from tracee's memory and the tracer actually resuming the tracee using &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; which allows a potentially malicious thread inside the tracee to change the value of the memory &lt;i&gt;path&lt;/i&gt; points to and thus circumvent any restriction imposed by the tracer. Changing the value is as simple as writing to the process memory, which is shared between threads, at just the right moment and to just the right position.&lt;br&gt;As writing to memory will not generate a trap the tracer could act upon the tracer would be unaware of the modification and it is just about to resume the tracee's execution - &lt;i&gt;jail broken&lt;/i&gt;.&lt;br&gt;&lt;br&gt;What is important here is just the right timing. The write has to happen after the tracer has read from the tracee's memory and before it resumes execution of the tracee. However, the tracer is most likely to employ some kind of decision-finding process here. This process will take time. It may actually involve some syscalls (think mutexes, semaphores and condition variables here). All in all enough time to swap values.&lt;br&gt;&lt;br&gt;You may now think to yourself that it might be really hard to actually pull this one off and it probably is in normal circumstances. However, the possibility to do this alone should rule-out ptrace as a security measure completely.&lt;br&gt;&lt;br&gt;The only way I believe this could be handled is triggering a hook inside the system call handlers themselves, just after all information has been pulled from userspace. These values are guaranteed not to be modifiable from within userspace and thus only these should be considered for making decisions. As a consequence ujail (and every other similar security measure out there) will have to be realized at least partly in kernel-space.&lt;br&gt;&lt;br&gt;Feel free to leave comments, send me an email and/or point out any issues with the proof of concept code or my idea.&lt;/p&gt;</description><category>ujail</category><category>sandbox</category><category>ptrace</category><category>security</category><category>GNU/Linux</category><guid>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</guid><pubDate>Fri, 24 Feb 2012 14:48:00 GMT</pubDate></item></channel></rss>