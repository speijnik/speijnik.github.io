<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Stephan's blog (python)</title><link>http://blog.sp.or.at</link><description>Stephan's notes on technology</description><lastBuildDate>Wed, 22 May 2013 18:25:16 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>git smart protocol via WebSockets - proof of concept</title><link>http://blog.sp.or.at/posts/201206git-smart-protocol-via-websockets-proof.html</link><description>&lt;p&gt;Yesterday an idea came to my mind: let's try running git's smart transport protocol via a WebSocket. In a few hours of work I came up with a solution which works.&lt;br&gt;&lt;br&gt;But why would one want to do that? Basically the only options for running git's smart protocol you have right now is either using git's own protocol or tunneling it via ssh. The first option leaves you without any ways of authentication - so it's only usable for read-only access to public repositories. The second option involves using an ssh server, which then allows read-write access and authentication, but is quite some work to set up.&lt;br&gt;As I am working on a university assignment which involves using WebSockets right now it occurred to me that there is no reason for not using WebSockets for this.&lt;br&gt;&lt;br&gt;The main idea is providing a tunnel, just like the ssh transport does, but this time via a WebSocket. The logic is the same and there is no modification to git itself required.&lt;br&gt;For now I have only implemented a proof of concept which allows you to update your repository from a remote system, but the approach should work perfectly well for pushing your changes to a remote repository too.&lt;br&gt;&lt;br&gt;Let's have a look at how this works.&lt;br&gt;On the local system &lt;i&gt;git-fetch-pack&lt;/i&gt; is invoked, which talks to a &lt;i&gt;git-upload-pack&lt;/i&gt; process on the remote end. The code I wrote provides a script which acts like an ssh client, but creates a WebSocket connection to the remote end, using Python and the &lt;a href="http://pypi.python.org/pypi/websocket-client/0.7.0"&gt;websocket-client&lt;/a&gt; Python package. On the other side of the tunnel a simple Python WSGI application, which uses &lt;a href="http://pypi.python.org/pypi/gevent-websocket/0.3.6"&gt;gevent-websocket&lt;/a&gt;, provides the server-side implementation.&lt;br&gt;Now when a WebSocket connection is established the server spawns a &lt;i&gt;git-upload-pack&lt;/i&gt; process and redirects its stdout to the WebSocket. Data which is received over the WebSocket is sent to the &lt;i&gt;git-upload-pack's &lt;/i&gt;stdin file descriptor.&lt;br&gt;On the client this logic is reversed, redirecting its stdout to the WebSocket and sending data received over the WebSocket to its stdin file descriptor.&lt;br&gt;&lt;br&gt;That's about it. Keep in mind this is a proof-of-concept, so there may be rough edges here and there and both stability and performance may be "sub-optimal".&lt;br&gt;I'd also like to point out that using WebSockets and HTTP as the underlying transport protocol gives one the opportunity to use standard HTTP(s) authentication mechanisms. This means that the WebSocket approach could be useful to git hosting sites, basically removing the need for running an ssh server.&lt;br&gt;&lt;br&gt;You can find the Python code over at &lt;a href="https://github.com/speijnik/gitws"&gt;https://github.com/speijnik/gitws&lt;/a&gt;. Have fun giving it a try.&lt;br&gt;&lt;br&gt;&lt;/p&gt;</description><category>http</category><category>gitws</category><category>websocket</category><category>git</category><category>proof of concept</category><category>python</category><guid>http://blog.sp.or.at/posts/201206git-smart-protocol-via-websockets-proof.html</guid><pubDate>Tue, 05 Jun 2012 05:08:00 GMT</pubDate></item><item><title>update-manager weekly update #6</title><link>http://blog.sp.or.at/posts/200907update-manager-weekly-update-6.html</link><description>&lt;p&gt;So finally I have the time to provide you with a weekly update, instead of my usual bi-weekly ones.&lt;br&gt;&lt;br&gt;Unfortunately I did not work on anything on last week's TODO list, but found other issues I worked on and corrected.  So let's have a look at what I've done.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Debian packaging update&lt;/strong&gt;&lt;br&gt;&lt;br&gt;I have done some work on the Debian packaging, which allows update-manager to be built using dpkg-buildpackage now. The way packages are splitted is not finalized yet and not up-to-date with my (and my mentor's) idea of how we should do that. You can expect an update to that soonish.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Automatically invoking package list reloading / update check&lt;/strong&gt;&lt;br&gt;&lt;br&gt;There is a command line switch (namely -c, or --check) now, that automatically performs an update check on startup. This gives other programs, like software-properties, a way of forcing a check when, for example, the package list sources have changed.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Checking/unchecking all updates in Gtk frontend&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Finally the small feature of selecting or deselecting all updates works in the Gtk frontend. Special cases like "all updates already checked" or "no updates checked" yet are handled too, meaning that you can only use one of these methods if it actually makes sense.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Package dependencies in python-apt backend and Gtk frontend&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Both the python-apt backend and the Gtk frontend are now aware of package dependencies. This means that when you select an upgrade that depends on another one that other update is selected too. The same works vice-versa too. Additionally the UI now lists all dependencies and dependencies on packages that are not installed yet and automatically deselects all updates that would requires new packages to be installed.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Displaying of overall download size in Gtk frontend&lt;/strong&gt;&lt;br&gt;&lt;br&gt;There has been a missing feature (ok, maybe a bug) so that the displayed download size would not be updated in the Gtk frontend. This has been fixed.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Install button being set sensitive correctly in Gtk frontend&lt;/strong&gt;&lt;br&gt;&lt;br&gt;In the past the install button would be set to either sensitive or insensitive at startup and not updated afterwards. That means if there were no packages to update when starting update-manager, then checking for updates where new updates are found, the install button would not be set sensitive again. I fixed that too.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Sorting of packages in Gtk frontend&lt;/strong&gt;&lt;br&gt;&lt;br&gt;In the Gtk frontend packages were not sorted at all, which meant that finding a specific package was rather hard. I added code that sorts the update list by package name now, which solves this issue.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Bugfixing humanize_size&lt;/strong&gt;&lt;br&gt;&lt;br&gt;The humanize_size method, which is responsible for human-readable size displaying in the Gtk frontend contained a major bug so that sizes were rounded. Again, I was able to solve this.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Next week's TODO list&lt;/strong&gt;&lt;br&gt;&lt;br&gt;As I didn't find time to work on last week's TODO list my new TODO list is in fact my old one, with additional "Bugfixing" and "Debian packaging" tasks:&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Downloading and installing of updates&lt;/li&gt;&lt;br&gt;&lt;li&gt;Bugfixing (?)&lt;/li&gt;&lt;br&gt;&lt;li&gt;Debian packaging&lt;/li&gt;&lt;br&gt;&lt;li&gt;Checking that everything is documented&lt;/li&gt;&lt;br&gt;&lt;li&gt;Even more unit tests&lt;/li&gt;&lt;br&gt;&lt;li&gt;Pylint checking&lt;/li&gt;&lt;br&gt;&lt;li&gt;If time permits and everything else works correctly: working on an aptdaemon backend&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;The next thing you can expect me to update is the Debian packaging and the documentation, which are my highest priority tasks for now, followed by support for downloading and installing updates.&lt;br&gt;&lt;br&gt;Happy hacking!</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><category>free software</category><guid>http://blog.sp.or.at/posts/200907update-manager-weekly-update-6.html</guid><pubDate>Thu, 09 Jul 2009 17:07:00 GMT</pubDate></item><item><title>update-manager weekly update #5</title><link>http://blog.sp.or.at/posts/200907update-manager-weekly-update-5.html</link><description>&lt;p&gt;Firstly I have to apologize again for not providing you with weekly update #4, but again I didn't have the time to write one, so this post is going to sum up everything that happened since my last update.&lt;br&gt;&lt;br&gt;Let's have a look at my previous TODO list:&lt;br&gt;&lt;br&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Even though my TODO list entry contained a more detailed entry I have updated the UpdateManager documentation as a whole, leaving only a few blank spots right now.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Ubuntu distribution specific code&lt;/strong&gt;&lt;br&gt;&lt;br&gt;I implemented changelog fetching for Ubuntu, which works just as fine as its Debian counterpart now.&lt;br&gt;&lt;br&gt;&lt;strong&gt;More unit tests&lt;/strong&gt;&lt;br&gt;&lt;br&gt;There are plenty of unit tests now, but not everything is being tested yet. I am especially proud of my Python interface validation code, that is being used in unit tests to check if handlers implement an interface correctly.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Update list downloading&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Checking for updates is what caused me major trouble in the past few days. Basically I had all the code ready, but for some reason the UI froze, with no apparent reason.&lt;br&gt;However, today I was able to finally identify and fix the problem. As I expected my code was just fine, but python-apt was messing up. I am going to discuss the exact problem and its solution later on, but first: a screenshot. :-)&lt;br&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a href="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Checking-for-updates.png"&gt;&lt;img alt="Update Manager update check" class="aligncenter size-thumbnail wp-image-151" height="150" src="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Checking-for-updates-150x150.png" title="Update Manager update check" width="150"&gt;&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;Note: As you probably noticed I replaced the default progressbar with a pulsating one, because we cannot get exact information on how many items/bytes to fetch and would likely get a progress bar moving backwards, which isn't beautiful.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Further changes&lt;/strong&gt;&lt;br&gt;&lt;br&gt;The TODO list was rather short and I did a lot of other work, which I want to elaborate on.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Dynamic selection of frontend, backend and distribution specific modules&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Even though this is probably not of any interest to John Doe, it helps a great deal when debugging code as all three components can be selected via separate command line switches now.&lt;br&gt;Additionally some magic has been put in place that automatically detects the system's distribution and loads the corresponding distribution specific module. This is done via lsb_release and the newly introduced code in UpdateManager.Util.lsb.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Pylint cleanup&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Just out of curiosity I decided to start a pylint run on the codebase and quite a few problems were detected, which I then fixed. To be honest though I added quite some code afterwards that probably needs pylint checking and fixes again.&lt;br&gt;&lt;br&gt;&lt;strong&gt;update-manager IPC&lt;/strong&gt;&lt;br&gt;&lt;br&gt;My original plan and IPC design involved using callback functions and passing them between the different modules. Even though this worked out fine I had the feeling this wasn't clean enough and decided to ditch this approach and replace it with handler classes.&lt;br&gt;The handler base classes now provide an interface of methods that are called on certain events and their implementations act accordingly. The main benefit was that I could easily drop a lot of enums and rather have different methods handling different events.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Gtk, threads and python-apt&lt;/strong&gt;&lt;br&gt;&lt;br&gt;With the new IPC approach it became easier to use threads that do the actual work in the background, which I had implemented in next to no time, but a few problems showed up.&lt;br&gt;Whilst cache reloading from within a thread worked just fine checking for updates did not, and until today I didn't know why. I spent a good amount of time debugging this issue, even using python profiling, but nothing obvious showed up. The background process was running, whilst the UI froze.&lt;br&gt;Today I finally found the root of the problem: python-apt. Even though I assumed that the python-apt worker threads must be stealing CPU time from the thread running gtk.main I wasn't sure how this could be happening, having two completely independent threads.&lt;br&gt;&lt;br&gt;Now, the cause of all this mess was that Python has a global threading lock and it seems as if this one is *LOCKED* when running C-code, such as the one python-apt comes with. The solution lies in calling Py_BEGIN_THREADS_ALLOW and Py_END_THREADS_ALLOW from within the C code, to release the global lock and let the Python interpreter do some work every now and then.&lt;br&gt;&lt;br&gt;As with the python-apt acquire code I was able to allow other threads to work as soon as the fetching code starts working and only disallow threads when actually modifying Python objects or calling methods and/or functions. Surprisingly python-apt already made use of this in its cache loading code, but not the fetch progress code.&lt;br&gt;Fixing this problem took me less than half an hour and you probably can't believe how glad I was to finally get things working again.&lt;br&gt;&lt;br&gt;&lt;strong&gt;UI updates &amp;amp; other changes&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Some details in the UI were anything but optimal, like horizontal scrollbars in a few places, which I removed. Additionally I saw the need to move some code out of the Gtk frontend's __init__.py file and to a separate ui.py file.&lt;br&gt;A full list of all changes I made is available from the bzr changelog at &lt;a href="http://bzr.debian.org/loggerhead/update-manager/devel/gsoc09/changes" title="update-manager changes @bzr.debian.org"&gt;bzr.debian.org&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;strong&gt;A few more screenshots&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Finally, I would like to provide you with two more screenshots (don't worry about my system being insecure because of not applied updates - this is a testing machine that is  not up-to-date on purpose):&lt;br&gt;&lt;br&gt;&lt;a href="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Update-Manager-1.png"&gt;&lt;img alt="Update Manager main screen" class="size-thumbnail wp-image-149 alignnone" height="150" src="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Update-Manager-1-150x150.png" title="Update Manager main screen" width="150"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a href="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Update-Manager.png"&gt;&lt;img alt="Update Manager main screen with details &amp;amp; changelog" class="size-thumbnail wp-image-150 alignnone" height="150" src="http://blog.peijnik.at/wp-content/uploads/2009/07/Screenshot-Update-Manager-150x150.png" title="Update Manager main screen with details &amp;amp; changelog" width="150"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;TODO list&lt;/strong&gt;&lt;br&gt;&lt;br&gt;My TODO list for next week:&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Downloading and installing of updates&lt;/li&gt;&lt;br&gt;&lt;li&gt;Checking that everything is documented&lt;/li&gt;&lt;br&gt;&lt;li&gt;Even more unit tests&lt;/li&gt;&lt;br&gt;&lt;li&gt;Pylint checking&lt;/li&gt;&lt;br&gt;&lt;li&gt;If time permits and everything else works correctly: working on an aptdaemon backend&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><category>free software</category><guid>http://blog.sp.or.at/posts/200907update-manager-weekly-update-5.html</guid><pubDate>Thu, 02 Jul 2009 09:29:00 GMT</pubDate></item><item><title>Python interface validation</title><link>http://blog.sp.or.at/posts/200906python-interface-validation.html</link><description>&lt;p&gt;When I started working on update-manager I thought using zope.interface for my interfaces was a good idea, but soon realized that it lacked a way of actually validating a given interface against an implementation. The only thing it did was checking whether the implementation defined that it implements the interface.&lt;br&gt;&lt;br&gt;Now, whilst writing some unit tests for update-manager I came up with a simple way of doing "real" validation, and I would like to share that Python code with you.&lt;br&gt;&lt;br&gt;Firstly, I'd like to give you an overview of which checks my code carries out:&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Mandatory method (raises NotImplementedError in interface definition) is not implemented (also raises NotImplementedError in implementation)&lt;/li&gt;&lt;br&gt;&lt;li&gt;Optional or mandatory method is of correct type (static method versus instance method)&lt;/li&gt;&lt;br&gt;&lt;li&gt;Optional or mandatory method has a different signature (argument count is different)&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;I consider at least the first and last check viable for validation of an interface against its implementation. The second check I listed is not that useful, and may produce false positives when someone uses certain decorators, I did not carry out any tests on that myself though.&lt;br&gt;&lt;br&gt;The code can be found in update-manager's repository (&lt;a href="http://bzr.debian.org/loggerhead/update-manager/devel/gsoc09/annotate/head:/tests/_helpers.py?" title="tests/_helpers.py @bzr.debian.org - update-manager gsoc09 repository"&gt;link&lt;/a&gt;) and (for now) is licensed under the GPLv2 or later. I am willing to distribute this code as a separate Python module (maybe under a more permissive license like the LGPL) if enough (let's say at least two) people are interested in it, so please let me know if you like it.&lt;br&gt;&lt;br&gt;Apart from the code itself the unit tests in the file linked above should explain how this beast exactly works.&lt;br&gt;&lt;br&gt;Happy hacking!</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><category>free software</category><guid>http://blog.sp.or.at/posts/200906python-interface-validation.html</guid><pubDate>Mon, 22 Jun 2009 20:30:00 GMT</pubDate></item><item><title>update-manager weekly update #2</title><link>http://blog.sp.or.at/posts/200906update-manager-weekly-update-2.html</link><description>&lt;p&gt;First of all: yes, I skipped update #1. I was rather busy with some assignments and exams at university and didn't work that much on update-manager the past two weeks.&lt;br&gt;&lt;br&gt;Anyways, this update contains everything that has happened since &lt;a href="http://blog.peijnik.at/2009/05/27/update-manager-weekly-update-0/" title="update-manager weekly update #0 @blog.peijnik.at"&gt;update #0&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Changelog fetching&lt;/strong&gt;&lt;br&gt;&lt;br&gt;The changelog fetching code has been added to update-manager. This means that the changelog will be shown in the details section now and should look the same it looked before. However, I have only written that code for Debian so far, but the Ubuntu part is on my TODO list.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;br&gt;&lt;br&gt;The documentation has been updated and uploaded to alioth and can be viewed &lt;a href="http://update-manager.alioth.debian.org/doc/current/" title="update-manager documentation @update-manager.alioth.debian.org"&gt;here&lt;/a&gt;. I have set up a python environment on alioth which allows building the documentation directly, rather than building it locally and uploading it then. Basically this works by having a separate python packages directory, containing some mock modules that are needed (think gtk and friends here), allowing us to build the docs without having to install all dependencies.&lt;br&gt;I am planning on elaborating on this method and how to create such an environment in one of my upcoming posts, so stay tuned if you could use something like this too.&lt;br&gt;&lt;br&gt;Additionally to this environment the documentation has been updated a great deal, including more modules and containing documentation for previously undocumented methods and classes.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Application module&lt;/strong&gt;&lt;br&gt;&lt;br&gt;I have reworked some aspects of the UpdateManager.Application module, allowing me to do unit testing on pretty much every aspect of the class. The problem I fixed here is that Application directly called sys.exit when something went wrong and now raises exceptions, which contain the status code and are handled in the respective scripts (ie. "update-manager").&lt;br&gt;&lt;br&gt;&lt;strong&gt;Gtk Frontend and updates from another thread&lt;/strong&gt;&lt;br&gt;&lt;br&gt;One thing I fixed was the problem caused by the changelog fetching code running in a separate thread and invoking a callback function that updates the UI. It seems as Gtk isn't that happy when you do this and the UI wouldn't be updated immediatly (it seemed that this only happened after some events, like scrolling the update list). This has been reworked and the callback function now checks if it was called from the main thread or not and calls gtk.gdk.threads_enter/_leave accordingly.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Changelog Viewer&lt;/strong&gt;&lt;br&gt;&lt;br&gt;After finishing the changelog fetching code I added the ChangelogViewer widget from previous update-manager versions again, supporting creation of links to launchpad and debian bugs (ie. LP:NNNNNN and Closes: #NNNNNN are now links) and displaying the version number in bold, among other things.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Weeding out UpdateManager.Frontend.Gtk.utils&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Initially I just copied over the utils module from old update-manager to the new implementation, leaving every single function in there, but now I decided to weed out the module. The result is that only the functions actually used by this implementation remained in there. Related to this documentation of that module is pending and on my TODO list.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Version number&lt;/strong&gt;&lt;br&gt;&lt;br&gt;After a chat with my mentor we decided to bump update-manager's version to 0.200-pre. This should make it easier to distinguish from the old version and indicates that a lot has changed. The first release following the -pre series will be 0.200.0, which should then include all functionality old update-manager included.&lt;br&gt;&lt;br&gt;&lt;strong&gt;My TODO list for next week&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Ordered by priority&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Documentation of UpdateManager.Frontend.Gtk.utils and .ChangelogViewer modules&lt;/li&gt;&lt;br&gt;&lt;li&gt;Ubuntu Distribution Specific code&lt;/li&gt;&lt;br&gt;&lt;li&gt;More unit tests&lt;/li&gt;&lt;br&gt;&lt;li&gt;Update list downloading in Gtk frontend&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><category>free software</category><guid>http://blog.sp.or.at/posts/200906update-manager-weekly-update-2.html</guid><pubDate>Fri, 19 Jun 2009 01:27:00 GMT</pubDate></item><item><title>Should CLI debug output and error messages be localized in a GUI application?</title><link>http://blog.sp.or.at/posts/200906should-cli-debug-output-and-error.html</link><description>&lt;p&gt;Whilst working on update-manager I have been wondering whether I should use gettext for localizing debug output and error messages sent to stderr.&lt;br&gt;As for debug output itself I basically do not see the need for providing a localized version for each and every message sent to stderr, but as far as error messages are concerned I am uncertain.&lt;br&gt;&lt;br&gt;The point is that update-manager (apart from its experimental text interface) is usually not launched from a terminal at all and so most users won't even see these messages ever. Also, I believe that every developer's English skills are good enough so that he or she is able to understand simple messages.&lt;br&gt;Error messages however might be useful to all users when they experience a problem with the software, but localizing those could make handling bug reports a bit harder, possibly having to translate the error message back to English before being able to see what has gone wrong.&lt;br&gt;&lt;br&gt;So basically I am asking you: What do you think? Is it worth localizing these messages? What is your experience with localized or non-localized error and debug messages?&lt;br&gt;&lt;br&gt;I would be glad if I could get some input from you, either as a comment to this article, via email to debian(dot)sp(dot)or(dot)at or through the &lt;a href="http://lists.alioth.debian.org/mailman/listinfo/update-manager-devel" title="update-manager-devel listinfo @lists.alioth.debian.org"&gt;update-manager-devel&lt;/a&gt; mailing list.&lt;/p&gt;</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><category>free software</category><guid>http://blog.sp.or.at/posts/200906should-cli-debug-output-and-error.html</guid><pubDate>Tue, 02 Jun 2009 05:55:00 GMT</pubDate></item><item><title>sphinx-aware Enums in Python</title><link>http://blog.sp.or.at/posts/200906sphinx-aware-enums-in-python.html</link><description>&lt;p&gt;As I promised to keep you updated on recent developments on update-manager I am writing this article. Just as a disclaimer: I am not going to write about any recent developments here, but would rather like to point at a piece of code I added to update-manager that could be useful in other applications too.&lt;br&gt;&lt;br&gt;Now, as the title suggests there are sphinx-aware Enums in update-manager. Enums are common constructs in other programming languages like C and allow simple creation of constants with, for example, ascending values (first constant has value 0, second has value 1 and so on). Python unfortunately does not include support for Enums itself, but I found it rather easy to write classes that emulate such a construct.&lt;br&gt;&lt;br&gt;Nothing is new about Enums in Python and there are probably quite a few different implementations out there, but I believe mine is different. The sphinx-aware part means that my implementation automagically updates the docstrings of the created instances and thus allows sphinx' "autodata" method to include sensible information in generated API documentation.&lt;br&gt;&lt;br&gt;I could go on writing about and praising my method, but I believe a short example gives you a better idea how my implementation works and what I wanted to achieve with this. Have a look at &lt;a href="http://update-manager.alioth.debian.org/doc/current/api/api/UpdateManager/Backend/index.html#UpdateManager.Backend.RELOAD_CACHE_STATUS" title="UpdateManager.Backend.RELOAD_CACHE_STATUS Enum (update-manager API doc) @update-manager.alioth.debian.org"&gt;this page&lt;/a&gt;, which is part of update-manager's new API documentation. You should see rather well-looking documentation of the &lt;em&gt;UpdateManager.Backend.RELOAD_CACHE_STATUS&lt;/em&gt; NegativeEnum, the defined constants, their values and some additional information about each value now.&lt;br&gt;&lt;br&gt;Still, nothing too fancy, HTML documentation generated from docstrings. What makes this special is the code from which it was generated:&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class="python" name="code"&gt;RELOAD_CACHE_STATUS = NegativeEnum(&lt;br&gt;  BEGIN = "Started reloading package cache",&lt;br&gt;  DONE = "Finished reloading package cache")&lt;/pre&gt;&lt;br&gt;&lt;br&gt;This not only gives us a &lt;em&gt;RELOAD_CACHE_STATUS&lt;/em&gt; enum, along with the &lt;em&gt;RELOAD_CACHE_STATUS.BEGIN&lt;/em&gt; and &lt;em&gt;RELOAD_CACHE_STATUS.DONE&lt;/em&gt;, but also some documentation, included in &lt;em&gt;RELOAD_CACHE_STATUS&lt;/em&gt;' docstring, that can be used by sphinx.&lt;br&gt;&lt;br&gt;You can find the Enum code, which is rather short and should be quite easy to understand, &lt;a href="http://bzr.debian.org/loggerhead/update-manager/devel/gsoc09/annotate/head:/UpdateManager/Util/enum.py?" title="UpdateManager/Util/enum.py @bzr.debian.org/loggerhead"&gt;here&lt;/a&gt;. I hope you find this code as useful as I do.</description><category>gsoc</category><category>python</category><category>Debian</category><category>update-manager</category><guid>http://blog.sp.or.at/posts/200906sphinx-aware-enums-in-python.html</guid><pubDate>Mon, 01 Jun 2009 17:20:00 GMT</pubDate></item><item><title>python-argvalidate 0.9.0 released</title><link>http://blog.sp.or.at/posts/200903python-argvalidate-090-released.html</link><description>&lt;p&gt;Even though I planned providing a release candidate first, which can be seen in the project's &lt;a href="http://code.sp-its.at/projects/argvalidate/log?action=stop_on_copy&amp;amp;mode=stop_on_copy&amp;amp;rev=23&amp;amp;stop_rev=14&amp;amp;limit=100&amp;amp;verbose=on" title="Mercurial changelog between 0.8.2 and 0.9.0"&gt;Mercurial changelog&lt;/a&gt; I have released &lt;a href="http://code.sp-its.at/projects/argvalidate" title="python-argvalidate homepage @ code.sp-its.at"&gt;python-argvalidate&lt;/a&gt; 0.9.0 today. Tarballs can be obtained from the &lt;a href="http://pypi.python.org" title="Python Package Index"&gt;Python Package Index (pypi)&lt;/a&gt;, as usual.&lt;br&gt;&lt;br&gt;&lt;a name="more"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;So what's has changed compared to 0.8.2&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Basically a lot of code has been rewritten or reviewed and modified. The most important change lies in argvalidate's internals though.&lt;br&gt;Instead of relying on Python internals, those are the&lt;em&gt; func_*&lt;/em&gt; and &lt;em&gt;func_code.*&lt;/em&gt; attributes of every function argvalidate uses another mechanism for obtaining the information about functions now, the &lt;a href="http://docs.python.org/library/inspect.html" title="inspect Module documentation @ docs.python.org"&gt;inspect&lt;/a&gt; Module. In short this means that argvalidate should be more resistant to possible changes in the format of these attributes, because the &lt;em&gt;inspect&lt;/em&gt; Module that ships with Python should be changed accordingly and it is unlikely that its public interface is going to break.&lt;br&gt;&lt;br&gt;Which leads me straight to the next point regarding argvalidate: the public interface. The most visible change was the deprecation of the &lt;em&gt;method_args&lt;/em&gt;, &lt;em&gt;func_args&lt;/em&gt; and &lt;em&gt;return_value&lt;/em&gt; decorators. These decorators are still present, but will be removed in one of the next upcoming releases of argvalidate. The functionality of &lt;em&gt;method_args&lt;/em&gt; and &lt;em&gt;func_args&lt;/em&gt; has been combined into the &lt;a href="http://code.sp-its.at/doc/argvalidate/v0.9.0/argvalidate.html#argvalidate.accepts" title="argvalidate.accepts @ argvalidate 0.9.0 documentation"&gt;accepts&lt;/a&gt; decorator, whilst the &lt;a href="http://code.sp-its.at/doc/argvalidate/v0.9.0/argvalidate.html#argvalidate.returns" title="argvalidate.returns @ argvalidate 0.9.0 documentation"&gt;returns&lt;/a&gt; decorator replaces &lt;em&gt;return_value&lt;/em&gt;.&lt;br&gt;&lt;br&gt;accepts now includes some magic for automatically determining whether a function or method has been decorated. Initially the plan was on using inspect's &lt;a href="http://docs.python.org/library/inspect.html#inspect.ismethod" title="inspect.ismethod Module documentation @ docs.python.org"&gt;ismethod&lt;/a&gt; function, which did not work out as when the decorator is called for methods the method has not been bound to the class yet and looks like a simple function to ismethod. However, the magic added checks the first argument's name and decides that functions having either "&lt;em&gt;self&lt;/em&gt;" or "&lt;em&gt;cls&lt;/em&gt;" as their first parameter are methods, whilst everything else is a simple function.&lt;br&gt;&lt;br&gt;There is more to say about &lt;em&gt;accepts&lt;/em&gt;. Internally some checks which were done at every call to the decorated function in the past are now done only once, when the decorator is invoked. This should reduce the overhead argvalidate adds when the function (and thus the internal wrapper doing the checks) is called, but most likely will slow down decoration itself. However, decoration is only done once, whilst a function is likely to be called several times in its lifetime, which should give us an overall improvement of speed.&lt;br&gt;&lt;br&gt;The &lt;a href="http://code.sp-its.at/doc/argvalidate/v0.9.0/" title="argvalidate Documentation @ code.sp-its.at"&gt;documentation&lt;/a&gt; has been updated accordingly and can be found at the usual place.&lt;br&gt;&lt;br&gt;&lt;strong&gt;What's up next?&lt;/strong&gt;&lt;br&gt;&lt;br&gt;There is no real further &lt;a href="http://code.sp-its.at/projects/argvalidate/roadmap" title="argvalidate roadmap @ code.sp-its.at"&gt;roadmap&lt;/a&gt; for argvalidate right now. No issues were left open, except for Python 3 &lt;a href="http://code.sp-its.at/projects/argvalidate/ticket/3" title="ticket: Python3 compatibility meta @ code.sp-its.at"&gt;testing &amp;amp; support&lt;/a&gt;. Further releases are going to be made when needed, that is when you &lt;a href="http://code.sp-its.at/projects/argvalidate/newticket" title="argvalidate: submit bug report @ code.sp-its.at"&gt;submit&lt;/a&gt; a bug report and it is fixed.&lt;/p&gt;</description><category>foss</category><category>python</category><category>argvalidate</category><category>free software</category><guid>http://blog.sp.or.at/posts/200903python-argvalidate-090-released.html</guid><pubDate>Tue, 24 Mar 2009 15:02:00 GMT</pubDate></item></channel></rss>