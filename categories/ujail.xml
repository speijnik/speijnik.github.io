<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Stephan's blog (ujail)</title><link>http://blog.sp.or.at</link><description>Stephan's notes on technology</description><lastBuildDate>Wed, 22 May 2013 18:25:16 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>ptrace-based security just does not work</title><link>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</link><description>&lt;p&gt;In 2009 I &lt;a href="http://techandsp.blogspot.com/2009/12/introducing-ujail-proof-of-concept.html"&gt;wrote&lt;/a&gt; &lt;a href="http://techandsp.blogspot.com/2009/12/ujail-use-cases-faqs-part-1-proof-of.html"&gt;about&lt;/a&gt; building a ptrace-based sandboxing system named "ujail", including some basic proof of concepts.&lt;br&gt;&lt;br&gt;I have been thinking about this idea for a long time now, but sadly did not have the time to implement it - until now.&lt;br&gt;Right now I am working on this idea again and whilst doing some research I came across a &lt;a href="http://groups.google.com/group/linux.kernel/browse_thread/thread/4ef67613306dc260/b6fe32ed0fe7317a"&gt;thread&lt;/a&gt; on the linux-kernel mailing list.&lt;br&gt;At first a problem with 64-bit binaries trapping into 32-bit syscall handling code via int 80 got me there. While this is awkward and keeps one from implementing a sandbox in userspace (due to not being able to access &lt;i&gt;TS_COMPAT&lt;/i&gt;, as described in the thread) it led me to something else - a more severe problem.&lt;br&gt;Unfortunately I cannot remember who wrote this and am unable to recover the actual mail (if someone finds it I would be happy if you notified me), but someone mentioned race conditions when using &lt;i&gt;ptrace&lt;/i&gt; as a security measure.&lt;br&gt;&lt;br&gt;In short I came up with a proof of concept which works around possible limitations imposed by a ptrace-based security mechanism. For those in a hurry: you can find the code of the proof of concept at &lt;a href="https://github.com/speijnik/ptrace_security_flaws"&gt;github&lt;/a&gt;.&lt;br&gt;In the following parts of this article I would like to elaborate on the problem and how the proof of concept code exploits it.&lt;br&gt;&lt;a name="more"&gt;&lt;/a&gt;&lt;br&gt;The problem here is the fact that &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; traps &lt;b&gt;before&lt;/b&gt; the kernel actually fetches information from userspace.&lt;br&gt;Let me illustrate that with &lt;i&gt;sys_open&lt;/i&gt;. Assume we are running a tracer which makes use of ptrace to get a &lt;i&gt;SIGTRAP&lt;/i&gt; each time a tracee invokes a syscall and we want to impose limits on &lt;i&gt;sys_open&lt;/i&gt; calls.&lt;br&gt;&lt;br&gt;After a syscall has been invoked it would roughly work like this:&lt;br&gt;&lt;br&gt;The tracer is notified, evaluates the registers as read using &lt;i&gt;PTRACE_GETREGS&lt;/i&gt; and reads the first syscall argument's value (namely the path value) from the tracee. It then evaluates the value and decides whether to allow the syscall or not.&lt;br&gt;Now this is exactly the way ujail would have worked in its initial design. However, using this method there is a not-so-small attack vector which involves &lt;b&gt;all&lt;/b&gt; values read from the tracee's memory.&lt;br&gt;&lt;br&gt;You may now ask yourself what I am writing about, but it will make sense in a few moments, I promise.&lt;br&gt;&lt;br&gt;There is a timespan between the tracer reading the &lt;i&gt;path&lt;/i&gt; value from tracee's memory and the tracer actually resuming the tracee using &lt;i&gt;PTRACE_SYSCALL&lt;/i&gt; which allows a potentially malicious thread inside the tracee to change the value of the memory &lt;i&gt;path&lt;/i&gt; points to and thus circumvent any restriction imposed by the tracer. Changing the value is as simple as writing to the process memory, which is shared between threads, at just the right moment and to just the right position.&lt;br&gt;As writing to memory will not generate a trap the tracer could act upon the tracer would be unaware of the modification and it is just about to resume the tracee's execution - &lt;i&gt;jail broken&lt;/i&gt;.&lt;br&gt;&lt;br&gt;What is important here is just the right timing. The write has to happen after the tracer has read from the tracee's memory and before it resumes execution of the tracee. However, the tracer is most likely to employ some kind of decision-finding process here. This process will take time. It may actually involve some syscalls (think mutexes, semaphores and condition variables here). All in all enough time to swap values.&lt;br&gt;&lt;br&gt;You may now think to yourself that it might be really hard to actually pull this one off and it probably is in normal circumstances. However, the possibility to do this alone should rule-out ptrace as a security measure completely.&lt;br&gt;&lt;br&gt;The only way I believe this could be handled is triggering a hook inside the system call handlers themselves, just after all information has been pulled from userspace. These values are guaranteed not to be modifiable from within userspace and thus only these should be considered for making decisions. As a consequence ujail (and every other similar security measure out there) will have to be realized at least partly in kernel-space.&lt;br&gt;&lt;br&gt;Feel free to leave comments, send me an email and/or point out any issues with the proof of concept code or my idea.&lt;/p&gt;</description><category>ujail</category><category>sandbox</category><category>ptrace</category><category>security</category><category>GNU/Linux</category><guid>http://blog.sp.or.at/posts/201202ptrace-based-security-just-does-not.html</guid><pubDate>Fri, 24 Feb 2012 14:48:00 GMT</pubDate></item><item><title>ujail: use cases, FAQs, part 1 &amp; proof of concept, part 2</title><link>http://blog.sp.or.at/posts/200912ujail-use-cases-faqs-part-1-proof-of.html</link><description>&lt;p&gt;As I ran out of time whilst writing the "&lt;a href="http://techandsp.blogspot.com/2009/12/introducing-ujail-proof-of-concept.html"&gt;introducing ujail&lt;/a&gt;" post on monday I would like to further elaborate on the idea, giving you some examples of possible use cases and then having a look at FAQs regarding ujail. Additionally I have created a second proof of concept that should be a lot faster, see below for more details.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use cases of ujail&lt;/b&gt; &lt;br&gt;&lt;br&gt;Monday's post was rather technical, so let's have a look at possible use cases today.&lt;br&gt;&lt;br&gt;The main reason for both having the idea of ujail and starting working on it is my web server. I am running quite a few (S)CGI scripts there and, even though running them as different users, on a per-vhost basis, I have the impression of the whole thing being a bit insecure.&lt;br&gt;&lt;br&gt;Okay, PHP does provide its famous &lt;i&gt;open_basedir&lt;/i&gt; feature, but I am also running some Python applications which I simply cannot restrict easily. My first ideas involved adding something similar to open_basedir to Python, followed by the idea of replacing some C library functions, like fopen and friends on startup time.&lt;br&gt;&lt;br&gt;Whilst the adding open_basedir to Python would have involved changing a lot of Python's internals I soon discarded the library patching idea as those could be worked around by injected code directly invoking syscalls. It didn't take long for me to notice that I have to dig deeper. The idea of ujail was born and after coming up with the proof of concept this seems to be a viable solution.&lt;br&gt;&lt;br&gt;Now ujail is not only about protecting a web server from its web applications, but could do a lot more, for example:&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Creating a sandbox for untrusted code (socket&amp;amp;file i/o emulation)&lt;br&gt;&lt;/li&gt;&lt;li&gt;Implementing some sort of personal firewall (socket-call only emulation)&lt;/li&gt;&lt;li&gt;Testing applications that perform low-level system operations (read: package managers and friends, filesystem emulation)&lt;/li&gt;&lt;/ul&gt; I am sure you can come up with even more use-cases. What should be noted is that emulating a system call does not mean that one necessarily needs to emulate the whole filesystem. What can be done, for example, is patching through access to common files (libraries, executables, etc.) whilst maintaining a virtual filesystem for data that will eventually be modified. A copy-on-write approach is possible too, for example. There are multiple methods with which the multiple filesystem could be implemented, the most common would probably be using a state directory.&lt;br&gt;&lt;br&gt;&lt;b&gt;FAQs&lt;/b&gt;&lt;br&gt;&lt;br&gt;There have been some questions about ujail in comments to my first post which I would like to answer. Also, I have been thinking about things that are different about ujail compared to other virtualization techniques. Feel free to add additional questions either in a comment or drop me an email: debian at sp dot or dot at.&lt;br&gt;&lt;br&gt;&lt;ol&gt;&lt;li&gt;Could you change the license of ujail to ... ?&lt;br&gt;&lt;br&gt;Not likely to happen. The proof of concept's license is GPLv3 and the actual code's license will be too. However, ujail is a userspace application that does not need any modifications to the kernel so there should be no problems with porting ujail from GNU/Linux to any other system.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Does ujail work on operating systems other than GNU/Linux?&lt;br&gt;&lt;br&gt;Not yet. If it's technically possible to implement the technique on other operating systems I would be happy to accept patches.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Do I need to patch my kernel for ujail to work?&lt;br&gt;&lt;br&gt;No, ujail is running in userspace. The only thing it needs is Linux with support for PTRACE_SYSEMU.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from using LD_PRELOAD?&lt;br&gt;&lt;br&gt;With LD_PRELOAD one can replace library functions, but malicious code could still directly invoke syscalls, working around this protection completely. Also, statically linked binaries cannot be restricted with LD_PRELOAD.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from user-mode-linux?&lt;br&gt;&lt;br&gt;User-mode-linux (UML) works by emulating a full kernel in userspace and allows you to virtualize a whole Linux instance (including a new init process, etc). ujail is about providing a way of restricting a single process (and its childs) inside a running system in terms of access to syscalls and the partial emulation of those.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;How is this approach different from linux-vserver?&lt;br&gt;&lt;br&gt;Linux-vserver is a kernel patch and runs in kernel space, as opposed to ujail, which works in userspace.&lt;br&gt;Also, linux-vserver works similarly to user-mode-linux, providing a fully virtualized Linux instance.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Does the account running ujail need any special privileges?&lt;br&gt;&lt;br&gt;No, the only restrictions that apply are those of ptrace.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Where is the code?&lt;br&gt;&lt;br&gt;Right now ujail is in a planning phase, and only the proof of concept code has been written and published. The actual ujail code is yet to be written and the code will be hosted on &lt;a href="http://launchpad.net/ujail"&gt;launchpad.net&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;b&gt;Proof of concept, part 2&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;An anonymous person (who were you stranger?) added a comment to my first post, suggesting "&lt;i&gt;Also, why patch the process rather than just modifying its state and trapping into the kernel?&lt;/i&gt;". I have had a look at this approach earlier, but it didn't work out. However, I decided to give it yet another try and created a &lt;a href="http://bazaar.launchpad.net/%7Espeijnik/ujail/proof-of-concept/revision/3"&gt;second proof of concept&lt;/a&gt;. That code does not require patching any code, but only modifies the instruction pointer (eip) and the first register (eax). This should be a lot faster than patching the code.&lt;br&gt;&lt;br&gt;Technically the new main loop works by calling PTRACE_SYSEMU and waiting for a notification. It then saves the instruction pointer and switches to PTRACE_SYSCALL. As before it waits for the emulated syscall to exit and at this point sets eax from orig_eax and decreases the value of the instruction pointer by the size of the "&lt;i&gt;int $0x80&lt;/i&gt;" instruction. Another call to PTRACE_SYSCALL resumes the process. The next event is the process actually entering the real syscall and yet another one leaving the syscall again. These are resumed by PTRACE_SYSCALL and PTRACE_SYSEMU respectively. So, comparing this with the first approach we are only modifying two registers now, instead of writing to the TEXT area of the running process.&lt;br&gt;&lt;br&gt;Thanks should go to the anonymous commenter for making me give this approach another try.&lt;br&gt;&lt;br&gt;&lt;b&gt;Questions? Criticism? More ideas? Want to contribute?&lt;/b&gt;&lt;br&gt;&lt;br&gt;Coming to an end I would yet again like to let you know that I am  open for questions, criticism, more ideas and contributions in general. So if you are interested in this topic come join the discussion by either dropping me an email, writing a comment to this post or replying to this post on your own blog.</description><category>Technology</category><category>ujail</category><category>GNU/Linux</category><category>free software</category><guid>http://blog.sp.or.at/posts/200912ujail-use-cases-faqs-part-1-proof-of.html</guid><pubDate>Wed, 09 Dec 2009 09:16:00 GMT</pubDate></item><item><title>Introducing ujail &amp; proof of concept</title><link>http://blog.sp.or.at/posts/200912introducing-ujail-proof-of-concept.html</link><description>&lt;p&gt;Lately I have been thinking about methods to provide a stripped down, secured environment for running untrusted code on GNU/Linux. With this post I would like to present you with the first results of my research.&lt;br&gt;&lt;br&gt;&lt;b&gt;ujail - brief introduction&lt;/b&gt;&lt;br&gt;&lt;br&gt;I have chosen &lt;a href="http://launchpad.net/ujail"&gt;ujail&lt;/a&gt; as the name for the technique I am proposing. ujail stands for micro jail in userspace and, in itself, describes the concept briefly. The main idea is to have a userspace process monitor system calls of one of its childs and emulate some calls, if needed. This is done using ptrace and namely both PTRACE_SYSEMU and PTRACE_SYSCALL.&lt;br&gt;The ujail process should not be able to monitor syscalls, like strace does, but also intercept and emulate them.&lt;br&gt;&lt;br&gt;This sounds a lot like user mode linux (uml), but the method is different. Whilst uml comes with a complete kernel, emulates all system calls and this way provides a virtualized system, ujail is intended to only emulate some systemcalls, without emulating the kernel.&lt;br&gt;&lt;br&gt;&lt;b&gt;Revisiting PTRACE_SYSCALL &amp;amp; PTRACE_SYSEMU&lt;/b&gt;&lt;br&gt;&lt;br&gt;To better explain how the ujail technique works I would like to have a quick look at PTRACE_SYSCALL and PTRACE_SYSEMU again.&lt;br&gt;&lt;br&gt;PTRACE_SYSCALL allows a userspace process to be notified whenever a traced process enters or leaves a system call. This means that two notifications are normally sent: one before system call entry and one afterwards. Even though one is able to change the parameters of system calls this method does not allow system calls to be fully emulated (think virtual filesystem here).&lt;br&gt;&lt;br&gt;PTRACE_SYSEMU on the other hand provides one notification on syscall entry and expects the receiver of the notification to emulate the syscall. This method alone sounds great, but this also means that memory allocation needs to be emulated too, which is quite complex in userspace.&lt;br&gt;&lt;br&gt;&lt;b&gt;A hybrid of PTRACE_SYSCALL &amp;amp; PTRACE_SYSEMU&lt;/b&gt;&lt;br&gt;&lt;br&gt;Now on to the concept behind ujail. The method I am describing works by calling PTRACE_SYSEMU for a specific process and this way taking over emulation of all system calls. However, some system calls are complex to emulate in userspace, and so a hybrid of both PTRACE_SYSEMU and PTRACE_SYSCALL is needed. In short this works by checking whether the syscall needs to be emulated when the PTRACE_SYSEMU event is received.&lt;br&gt;Now one way is emulating the syscall, filling the processes' registers and resuming execution of the process. This is simple and straight-forward.&lt;br&gt;&lt;br&gt;The second way is forwarding the system call to the kernel. The problem here is that calling the syscall in the monitoring process will make the new resources available to that very process, and not the process to be jailed. This is where the hybrid method kicks in.&lt;br&gt;&lt;br&gt;The proof of concept code creates a backup of the next instruction to be executed along with a copy of the instruction pointer at this point and patches it with the opcodes for "int $0x80", causing the syscall to be made again. After that it resumes execution with PTRACE_SYSCALL and waits again. The first event to be received now is the program leaving the emulated system call, which can be ignored. Resuming yet again will give use two PTRACE_SYSCALL events, one for syscall entry and one for syscall exit.&lt;br&gt;&lt;br&gt;The first event is not really interesting, but at the second event the opcode backup is restored and the eip set from the saved value. Now the kernel has handled the syscall and the result is ready for the child process. A final call of PTRACE_SYSEMU resumes execution of the child and waits for the next syscall.&lt;br&gt;&lt;br&gt;&lt;b&gt;Proof of concept&lt;/b&gt;&lt;br&gt;&lt;br&gt;The proof of concept code can be downloaded from its &lt;a href="https://code.launchpad.net/%7Espeijnik/ujail/proof-of-concept"&gt;bazaar branch&lt;/a&gt; at launchpad.net. It is intended to be used on i386 systems only and works with simple programs, but is known not to work with anything using fork, vfork and most likely will not work for binaries using threading.&lt;br&gt;&lt;br&gt;Finally, I would like to thank &lt;a href="http://www.linuxjournal.com/user/800841" title="View user profile."&gt;Pradeep Padala&lt;/a&gt; for his "Playing with ptrace" articles &lt;a href="http://www.linuxjournal.com/article/6100"&gt;[0]&lt;/a&gt;&lt;a href="http://www.linuxjournal.com/article/6210"&gt;[1]&lt;/a&gt;, which were fun to read and worked as a great introduction of ptrace for me. &lt;br&gt;&lt;br&gt;Now there is only one thing left to say: if you are interested in this method, see loopholes or problems or want to contribute, please go ahead and contact me:&lt;br&gt;&lt;br&gt;debian at sp dot or dot at&lt;/p&gt;</description><category>Technology</category><category>ujail</category><category>GNU/Linux</category><category>free software</category><guid>http://blog.sp.or.at/posts/200912introducing-ujail-proof-of-concept.html</guid><pubDate>Mon, 07 Dec 2009 15:49:00 GMT</pubDate></item></channel></rss>